Em entrevistas de emprego, provas e avaliações no geral, normalmente pede-se para fazer programas. Aqui estão alguns programas "fundamentais" de saber fazer e alguns outros avulsos.

⚪⚪⚪ Programas fundamentais ⚪⚪⚪

⚪ Fibonacci series ⚪
## Sem recursão
	#include <stdio.h>
	int main(){
	    int n, i, n1 = 0, n2 = 1, n3;
	    scanf("%d", &n);
	    printf("\n%d %d", n1, n2);
	    for(i=2; i<n; i++){
		n3 = n1 + n2;
		printf(" %d", n3);
		n1 = n2;
		n2 = n3;
	    }
	    return 0;
	}
##
## Com recursão
	#include <stdio.h>
	void fibas(int n){
	    static int n1 = 0, n2 = 1, n3; //ser static é fundamental
	    if(n>0){
		n3 = n1 + n2;
		printf("%d ", n3);
		n1 = n2;
		n2 = n3;
		fibas(n-1);
	    }
	}
	int main(){
	    int n;
	    scanf("%d", &n);
	    printf("\n%d %d ", 0, 1);
	    fibas(n-2);
	    return 0;
	}
##

⚪ Número é primo?  ⚪
##
	#include <stdio.h>
	int main(){
	    int n, i, count = 0;
	    scanf("%d", &n);
	    for(i=1; i<=n; i++){
		if(n%i == 0){
		    count++;
		}
	    }
	    if(count == 2){
		printf("\n%d é primo\n", n);
	    } else{
		printf("\n%d Não é primo\n", n);
	    }
	    return 0;
	}
##

⚪ Reversed number & Polindrome ⚪
##
	#include <stdio.h>
	int main(){
	    int n, r, temp, rev=0;
	    scanf("%d", &n);
	    temp = n;
	    while(n!=0){
		r = n%10;
		rev = (rev*10)+r;
		n = n/10;
		//o arredondamento "padrão" (por ser int) é a chave.
	    }
	    printf("n: %d\n", temp);
	    printf("n⁻¹: %d\n", rev);
	    if(temp == rev){
		printf("É polindromo!");
	    }else{
		printf("Não é polindromo!");
	    }
	    return 0;
	}
##

⚪ Fatorial ⚪
## Loop:
	#include <stdio.h>
	int main(){
	    int n, i, fat=1;
	    scanf("%d", &n);
	    for(i=1; i<=n; i++){
		fat *= i;
	    }
	    printf("%d", fat);
	    return 0;
	}
## recursão:
	#include <stdio.h>
	int fat(int x){
	    if(x==0) return 1;
	    if(x>=1) return (x*fat(x-1));
	    if(x<0) return 0;
	}
	int main(){
	    int n;
	    scanf("%d", &n);
	    printf("%d", fat(n));
	    return 0;
	}
##


⚪ Soma dos digitos de um número ⚪
##
	#include <stdio.h>
	int main(){
	    int n, temp, aux, p = 0;
	    scanf("%d", &n);
	    aux = n;
	    while(n!=0){
		temp = n%10;
		p += temp;
		n=n/10;
	    }
	    printf("n = %d\nSum = %d", aux, p);
	}
##

⚪ Multiplicação de matrizes (dominando os loops) ⚪ 
##
	#include<stdio.h>    
	#include<stdlib.h>  
	int main(){  
	    int a[10][10],b[10][10],mul[10][10],r,c,i,j,k;    
	    system("clear");  
	    printf("número de linhas da matriz (max = 10): ");    
	    scanf("%d",&r);    
	    printf("número de colunas da matriz (max = 10): ");    
	    scanf("%d",&c);
	    printf("Matriz 1\n");
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){
		    printf("elemento [%d][%d] = ", i, j);
		    scanf("%d",&a[i][j]);   
		}
	    }

	    printf("Matriz 2\n");
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){
		    printf("elemento [%d][%d] = ", i, j);
		    scanf("%d",&b[i][j]);    
		}
	    }
	    system("clear");
	    printf("fazendo a multiplicação...\n");    
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){    
		    mul[i][j]=0;    
		    for(k=1;k<=c;k++){    
		        mul[i][j]+=a[i][k]*b[k][j];    
		    }    
		}    
	    }
	    
	 
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){    
		    printf("%d\t",a[i][j]);    
		}    
		printf("\n");    
	    }
	    printf("\nx\n\n");
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){    
		    printf("%d\t",b[i][j]);    
		}    
		printf("\n");    
	    }
	    printf("\n=\n\n");
	    for(i=1;i<=r;i++){    
		for(j=1;j<=c;j++){    
		    printf("%d\t",mul[i][j]);    
		}    
		printf("\n");    
	    }    
	    return 0;  
	}  
##

⚪  Pirâmide de números ⚪
##
	#include<stdio.h>    
	#include<stdlib.h>  
	int main(){  
	int i,j,k,l,n;    
	system("clear");  
	printf("Quantas linhas: ");    
	scanf("%d",&n);   
	for(i=1;i<=n;i++){  
	    for(j=1;j<=n-i;j++){    
		printf(" ");    
	    }    
	    for(k=1;k<=i;k++){    
		printf("%d",k);    
	    } 
	    for(l=i-1;l>=1;l--){    
		printf("%d",l);    
	    }  
	    printf("\n");    
	}
	// cada linha é a composição/concatenação:
	// número de espaços + sequencia crecente + sequencia decrescente
	return 0;  
	} 
##

⚪⚪ Sortings ⚪⚪
É EXTREMAMENTE IMPORTANTE que você leia/interprete o código linha por linha. Só vendo e testando para entender.

⚪ bubble sorting ⚪
Vai iterar pela array varias vezes e em cada iteração vai colocar o menor valor da array no index 0. Usando nested loops e reconhecimento de padroẽs, podemos reduzir o número de iterações necessárias, mas ainda sim esse processo é custoso.
##
	#include <stdio.h>
	int main(){
	    int size, i, j, temp;
	    int array[20];
	    printf("Diga o tamanho da array(máx = 20): ");
	    scanf("%d", &size);
	    printf("Diga os elementos da array: ");
	    for (i = 0; i < size; i++){
		 scanf("%d", &array[i]);   
	    }
	    //fazendo o bubble sorting
	    for (i = 0; i < size - 1; i++){
		for (j = 0; j < size - i - 1; j++){
		    if (array[j] > array[j+1]){
		        temp = array[j];
		        array[j] = array[j+1];
		        array[j+1] = temp;
		    }
		    //Caso inuput = -1, 2, 3, 17, 0 
		    // i = 0:  -1, 2, 3, 0, 17
		    // i = 2:  -1, 2, 0, 3, 17
		    // i = 3:  -1, 0, 2, 3, 17
		    //lembrando que, para cada iteração de "i", é nessário iterar todas de "j"
		}
	    }
	    printf("elementos em ordem crescente:\n");
	    for (i = 0; i < size; i++){
		printf("%d ", array[i]);   
	    }
	    return 0;
	}
##

⚪ Selection Sorting ⚪
vai "dividir" uma array em duas, de modo que a primeira parte é vazia e a segunda está com elementos não sortidos. O algoritimo vai iterar várias vezes, até que o a segunda parte da array esteja vazia e qua a primeira esteja sortida. Demora mais que o bubble sorting

##
	#include<stdio.h>
	void main(){
	    int size, i, j, min, temp;
	    int a[20];
	    
	    printf("Tamnho da array: ");
	    scanf("%d",&size);
	    printf("Diga os %d elementos: ", size);
	    for(i = 0 ; i < size; i++){
		scanf("%d", &a[i]);
	    }
	    // Selection Sorting 
	    for(i = 0; i < size - 1; i++){
		min = i; // min = 3;
		for(j = i + 1; j < size; j++){
		    if(a[min] > a[j]){
		        min = j;
		    }
		}
		if(min != i){
		    temp = a[i];
		    a[i] = a[min];
		    a[min] = temp;
		}
	    }
	    
	    printf("Elementos em ordem crescente:\n");
	    for(i = 0; i < size; i++){
		printf("%d ", a[i]);
	    }
	}
##

⚪ Merge sorting ⚪
Vai separar a array em vários pedaços diferentes, e tratar cada pedaço diferente como uma valor, depois vai organizar qual pedaço é o maior e então juntar/fundir os pedaços na araay final. É mais lento que as outras porém é o mais efeiciente em longas arrays, sendo mais preferido no geral.
##
	#include<stdio.h>
	//Assinaturas. Só estética.
	void sort(int array[], int i, int j);
	void merge(int array[], int ii, int ij, int jj, int ji);
	int main(){
	    int array[100], size, i;
	    printf("Tamanho da array: ");
	    scanf("%d",&size);
	    
	    printf("\nDigite os %d elementos da array:\n", size);
	    for(i = 0; i < size; i++){
		scanf("%d", &array[i]);
	    }
	    
	    //merge sort
	    sort(array, 0, size-1);
	    
	    printf("\nElementos ordenados:\n");
	    for(i=0; i < size; i++){
		printf("%d ", array[i]);   
	    }
	    return 0;
	}

	void sort(int array[], int i, int j){
	    int mid;
	    if(i < j){
		mid = (i+j)/2;
		sort(array, i, mid);
		sort(array, mid+1, j); 
		merge(array, i, mid, mid+1, j);
	    }
	}

	void merge(int array[], int ii, int ij, int jj, int ji){
	    int temp_array[50];
	    int c1, c2, c3;
	    c1 = ii;
	    c2 = jj;
	    c3 = 0;
	    
	    while(c1 <= ij && c2 <= ji){
		if(array[c1] < array[c2]){
		    temp_array[c3++] = array[c1++];  
		} else{
		    temp_array[c3++] = array[c2++];
		}
	    }
	    
	    while(c1 <= ij){
		temp_array[c3++] = array[c1++];
	    }
	    
	    while(c2 <= ji){
		temp_array[c3++] = array[c2++]; 
	    }
	    
	    for(c1 = ii, c2 = 0; c1 <= ji; c1++, c2++){
		array[c1] = temp_array[c2]; 
	    }
	}
##


⚪⚪⚪ Programas Avulsos ⚪⚪⚪


⚪ Caluculando a aproximação do cos(x) através de uma serie de taylor ⚪
##
##

#include <stdio.h>
#include <math.h>

#define PI 3.1415926

void main(){
    float ang, angR, k;
    int i, j;
    static long fat = 1;
    do{
        printf("Diga um angulo entre 0 e 360: ");
        scanf("%f", &ang);
    } while(ang < 0 || ang > 360);
    
    angR = ang*PI/180;
    printf("Seu ângulo em rad vale: %.4f\n", angR);
    do{
    printf("\nDiga quantas iterações você quer (máx: 15)\n");
        printf("-> ");
        scanf("%d", &j);
    } while(j>20);
    
    for(i = 0; i < j; i++ ){
        k = k + ( ( pow(-1.0 , i)*pow(angR, (2.0*i)) ) / fat );
        fat = fat * (2*i+1) * (2*i+2);
    }
    printf("\nO cos(%.3f) = %.4f\n", angR, k);
}

##
##


⚪ Distância entre pontos no espaço ⚪
##

#include<stdio.h>
#include<math.h>

struct ponto{
    float x;
    float y;
    float z;
};

float calcDis(float x1, float y1, float z1, float x2, float y2, float z2){
    return sqrt((pow((x2-x1), 2) + pow((y2-y1), 2) + pow((z2-z1), 2)));
}

void main(){
    struct ponto p1;
    struct ponto p2;
    struct ponto p3;
    char resp;
    
    printf("Diga as cordenadas do ponto 1 (x y z): ");
    scanf("%f %f %f", &p1.x, &p1.y, &p1.z);
    printf("Seu ponto 1:(%.2f, %.2f, %.2f)\n",p1.x, p1.y, p1.z);
    
    printf("\nDiga as cordenadas do ponto 2 (x y z): ");
    scanf("%f %f %f", &p2.x, &p2.y, &p2.z);
    printf("Seu ponto 2:(%.2f, %.2f, %.2f)\n",p2.x, p2.y, p2.z);
    
    printf("\nDiga as cordenadas do ponto 3 (x y z): ");
    scanf("%f %f %f", &p3.x, &p3.y, &p3.z);
    printf("Seu ponto 3:(%.2f, %.2f, %.2f)\n",p3.x, p3.y, p3.z);
    
    do{
        printf("\n-----------------------\n");
        printf("Que calculo quer fazer?\n");
        printf("\n-> distancia entre p1 e p2 (1)\n");
        printf("-> distancia entre p1 e p3 (2)\n");
        printf("-> distancia entre p2 e p3 (3)\n");
        printf("-> Sair(S)\n");
        printf("-----> ");
        resp = getchar();
    } while(resp != '1' && resp != '2' && resp != '3' && resp != 'S');
   
    switch(resp){
        //float x1, float y1, float z1, float x2, float y2, float z2
        case '1':
            printf("A distancia entre p1 e p2 é: %f", calcDis(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z));
            break;
        case '2':
            printf("A distancia entre p1 e p3 é: %f", calcDis(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z));
            break;
        case '3':
            printf("A distancia entre p2 e p3 é: %f", calcDis(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z));
            break;
        case 'S':
            printf("\nsaindo ...\n");
            break;
    }
}

##


⚪ analisando vetores ⚪
##

#include<stdio.h>
#define MAX 10

void main(){
    double vet[MAX], ord[MAX];
    double min, max;
    int i, j, pMax, pMin;
    printf("Diga 10 números para colocar no vetor: ");
    for(i=0; i<MAX; i++){
        fflush(stdin);
        scanf("%10lf", &vet[i]);
        printf("O elemento na posição %d é: %4.2lf\n\n", i, vet[i]);
    }
    
    
    for(i=0; i<MAX; i++){
        if(vet[i] > vet[pMax]){
            pMax = i;
        }
    }
    printf("O maior elemento é: v[%d] = %.2lf\n", pMax, vet[pMax]);
    
    for(i=0; i<MAX; i++){
        if(vet[i] < vet[pMin]){
            pMin = i;
        }
    }
    printf("O menor elemento é: v[%d] = %.2lf\n", pMin, vet[pMin]);
}
##


⚪ Como calcular um raiz quadrada ⚪
##
##
	#include<stdio.h>

	float raizQuadrada(float num){
	    float b = num, a = 1, error= 0.000001;
	    while(b-a >= error){
		b = (a+b)/2;
		a = num/b;
	    }
	    return b;
	}

	long int potencia(int base, int expoente){
	    int i, res=1;
	    for(i=0; i<expoente; i++){
		res *= base;
	    }
	    return res;
	}

	void main(){
	    printf("2 elevado à 10 é: %ld\n", potencia(2, 10));
	    printf("A raiz quadrada de 27.7 é: %6.3f", raizQuadrada(27.7));
	}
##
##

⚪ Calculo de horas ⚪
##
	#include<stdio.h>
	void main(){
	    int horaInicial, minutoInicial, horaFinal, minutoFinal, deltaH, deltaM;
	    printf("Diga somente a hora deinicio do jogo: ");
	    scanf("%d", &horaInicial);
	    printf("O jogo começou as %d horas e quantos minutos? ", horaInicial);
	    scanf("%d", &minutoInicial);
	    printf("Qual a hora de finalização do jogo? ");
	    scanf("%d", &horaFinal);
	    printf("O jogo finalizou as %d horas e quantos minutos? ", horaFinal);
	    scanf("%d", &minutoFinal);
	    
	    printf("\nInício: %d:%d\n", horaInicial, minutoInicial);
	    printf("Final: %d:%d\n", horaFinal, minutoFinal);
	    
	    horaInicial = horaInicial*60;
	    minutoInicial += horaInicial;
	    
	    horaFinal = horaFinal*60;
	    minutoFinal += horaFinal;
	    
	    deltaM = minutoFinal - minutoInicial;
	    deltaH = 0;
	    while(deltaM >= 60){
		deltaM -= 60;
		deltaH += 1;
	    }    
	    printf("\ntempo de jogo: %d horas e %d minutos", deltaH, deltaM);
	}
##


⚪ Divisores de n números ⚪
##
	#include <stdio.h>
	int main(){
	    int qtd, i = 0, j = 0;
	    int vet[10];
	    char resp[10];
	    printf("Quantos números? ");
	    scanf("%d", &qtd);
	    printf("Diga os números: \n");
	    while(i<qtd){
		printf("-> ");
		scanf("%d", &vet[i]);
		i++;
	    }
	    
	    for(i=0;i<qtd;i++){
		printf("\n\n");
		printf("Divisores de %d\n", vet[i]);
		for(j=vet[i]; j>0; j--){
		    if(vet[i] % j == 0){
		    printf("%d é divisor de %d\n", j, vet[i]);
		    }
		}
	    }
	    return 0;
	}

##

⚪ Criando um retângulo dinâmicamente ⚪
##
	#include <stdio.h>
	void base(int largura){
	    int i = 0;
	    printf("+");
	    while(i<largura){
		printf("-");
		i++;
	    }
	    printf("+\n");
	}
	void altura(int altura, int largura){
	    int i = 0, j = 0;
	    while(i<altura){
		j=0;
		printf("|");
		while(j<largura){
		    printf(" ");
		    j++;
		}
		printf("|\n");
		i++;
	    }
	}

	int main(){
	    int lar, alt;
	    printf("Diga quantas unidades de largura: ");
	    scanf("%d", &lar);
	    printf("Diga quantas unidades de altura: ");
	    scanf("%d", &alt);
	    base(lar);
	    altura(alt, lar);
	    base(lar);
	    return 0;
	}
##

⚪ Usando a função system() para executar comandos pelo terminal e matar processos ⚪
##
##
	#include <stdio.h>
	#include<stdlib.h>
	#include <string.h>

	void main(){
	    FILE *arquivo;
	    char linhaAtual[30], code[50], resp[20];
	    char *pointerDaLinha;

	    printf("\nAntes de usar o 'system' e criar o arquivo\n");
	    system("ps -e > abacate.txt");
	    printf("Depois de usar o 'system' e ciar o arquivo\n");
	    printf("\nAbrindo o arquivo...\n");
	    arquivo = fopen("abacate.txt", "rt");
	    if(arquivo == NULL){
	      printf("falha em ler o arquivo");
	      exit(1);
	    }
	    printf("Aberto\n");
	    printf("Lendo o arquivo...\n\n");
	    while(!feof(arquivo)){
	      pointerDaLinha = fgets(linhaAtual, 25, arquivo);
	      printf("%s", linhaAtual);
	    };
	 
	    printf("\nDiga o PID para terminar: ");
	    scanf("%s", resp);
	    strcat(code, "kill -9 ");
	    strcat(code, resp);
	    strcat(code," && echo 'Processo eliminado'");

	    printf("\nExecutando: %s\n", code);
	    system(code);
	    //printf("Processo eliminado\n");
	    
	    printf("\nFechando arquivo...\n");
	    fclose(arquivo);
	    printf("Aquivo fechado\n\n");
	}
##
##

⚪ criando uma stack do jeito raiz ⚪
##
##

#include <stdio.h>
#include<stdlib.h>

struct Pilha {
	int topo; /* vai guardar a posição do elemento no topo */
	int capa;
	float *pElem;

};

void criarPilha( struct Pilha *p, int c){
   p->topo = -1; //passada uma struct do tipo Pilha. && Por padrão, a ultima posição SEMPRE é -1.
   p->capa = c; //usa-se "->" para se referir a uma propriedade dessa struct. "capa" é o tamanho da stack, passado na função como "c"
   p->pElem = (float*) malloc(c*sizeof(float)); //vai alocar/criar memória para a Stack/pilha de acordo com o tamanho maximo dela
}
int empty(struct Pilha *p){
   if( p->topo == -1 )
      return 1; //se o primeiro elemento é -1 significa que ele também é o ultimo, logo a pilha está vazia
   else
      return 0;
}
int full(struct Pilha *p){
	if (p->topo == p->capa - 1)
		return 1; //se o "index" do ultimo elemento é igual ao tamanho definido para a pilha, então ela está cheia.
	else
		return 0;
}

void add(struct Pilha *p, float value){
	p->topo++; //aumenta o "index" do value antes de mesmo de atribuir algo à essa posição
	p->pElem[p->topo] = value; //value vai ser o valor do elemento da stack cujo index é igual ao "topo" atual.

}

float pop(struct Pilha *p){
   float aux = p->pElem[p->topo]; //salva o valor "mais alto" na stack
   p->topo--; //"diminue o indice" (aparentemente é o suficiente para desvincular/retirar o valor)
   return aux; //retorna o valor do "topo antigo"

}
float lastElem(struct Pilha *p){
   return p->pElem [p->topo]; //simplismente retorna o "valor mais alto" na stack
}

int main(){
	struct Pilha pilha1;
	int size, fluxo;
	float value;

	printf( "\nQual o tamanho da pilha? ");
	scanf( "%d", &size);

	criarPilha (&pilha1, size); //lebre de que, quando se passa uma struct deve-se usar o seu endereço(&)

	while(1){ 
	//loop infinito
		printf("\n1- Empilhar (push)\n");
		printf("2- Desempilhar (Pop)\n");
		printf("3- Mostrar o topo\n");
		printf("4- sair\n");
		printf("\n-> ");
		scanf("%d", &fluxo);

		switch (fluxo){
			case 1: //push
				if(full(&pilha1) == 1)
					printf("\nSua pilha está cheia.\n");
				else {
					printf("\nValor para adicionar: ");
					scanf("%f", &value);
					add(&pilha1, value);
				}
				break;

			case 2: //pop
				if(empty(&pilha1) == 1)
					printf( "\nSua pilha já está vazia\n");
				else{
					value = pop(&pilha1);
					printf ("\n%.2f foi removido da pilha\n", value);
				}
				break;

			case 3: // mostrar o topo
				if (empty(&pilha1) == 1)
					printf( "\nVocê ainda não adicionou nada!\n" );
				else {
					value = lastElem(&pilha1);
					printf("\nO valor no topo da stack é: %.2f\n", value);
				}
				break;
			case 4: 
				exit(0); //sai do programa, logo sai do loop infinito

			default: 
			    printf("\nOpção inválida\n");
		}
	}
}
##
##

